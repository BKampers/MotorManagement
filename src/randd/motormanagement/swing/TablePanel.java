/*
** Copyright Â© Bart Kampers
*/

package randd.motormanagement.swing;

import java.awt.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.table.*;
import javax.swing.text.*;

import randd.motormanagement.system.*;


public class TablePanel extends JPanel {

    
    public interface Listener {
        void startIndexPoll(Table table);
        void setValue(Table table, int column, int row, float value);
    }
    

    public TablePanel(Listener listener, Table table) {
        assert listener != null;
        this.tablePanelListener = listener;
        setTable(table);
        initComponents();
        grid.setDefaultRenderer(Object.class, new CellRenderer());
        grid.setDefaultEditor(Object.class, new NumberCellEditor());
        grid.getSelectionModel().addListSelectionListener(new GridSelectionListener());
        JTableHeader columnHeader = grid.getTableHeader();
        columnHeader.setDefaultRenderer(new ColumnHeaderRenderer(grid));
        columnHeader.setResizingAllowed(false);
        columnHeader.setEnabled(false);
        RowHeaders rowHeaders = new RowHeaders();
        rowHeaders.initialize(model, scrollPane, grid.getRowHeight());
        rowHeaders.setAlignment(JLabel.RIGHT, JLabel.TOP);
        numberFormat.setGroupingUsed(false);
    }
    
    
    Table getTable() {
        return table;
    }
    
    
    private void setTable(Table table) {
        if (this.table != null) {
            this.table.removeListener(tableListener);
        }
        this.table = table;
        if (table != null) {
            table.addListener(tableListener);
        }
    }
    
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        scrollPane = new javax.swing.JScrollPane();
        grid = new javax.swing.JTable();

        setLayout(new java.awt.BorderLayout());

        grid.setModel(model);
        grid.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_OFF);
        grid.setCellSelectionEnabled(true);
        grid.setGridColor(new java.awt.Color(0, 0, 0));
        grid.setRowHeight(30);
        grid.getTableHeader().setReorderingAllowed(false);
        scrollPane.setViewportView(grid);

        add(scrollPane, java.awt.BorderLayout.CENTER);
    }// </editor-fold>//GEN-END:initComponents


    private class GridModel extends DefaultTableModel {
        
        @Override
        public int getColumnCount() {
            return (table != null) ? table.getColumnCount() : 0;
        }

        @Override
        public int getRowCount() {
            return (table != null) ? table.getRowCount() : 0;
        }
        
        @Override
        public String getColumnName(int column) {
            Measurement columnMeasurement = table.getColumnMeasurement();
            if (columnMeasurement != null) {
                float stepSize = (columnMeasurement.getMaximum() - columnMeasurement.getMinimum()) / table.getColumnCount();
                return Integer.toString((int) (columnMeasurement.getMinimum() + column * stepSize));
            }
            else {
                return Integer.toString(column + 1);
            }
        }
        
        @Override
        public Object getValueAt(int row, int column) {
            return table.getField(column, row);
        }
        
        @Override
        public void setValueAt(Object value, int row, int column) {
            try {
                tablePanelListener.setValue(table, column, row, ((Number) value).floatValue());
            }
            catch (ClassCastException ex) {
                JOptionPane.showMessageDialog(
                    TablePanel.this, 
                    value.toString(), 
                    "Invalid input",
                    JOptionPane.ERROR_MESSAGE);
            }
        }

    }
    
    
    private class GridSelectionListener implements ListSelectionListener {
        
        @Override
        public void valueChanged(ListSelectionEvent e) {
            followActiveCell = false;
        }

    }

    
    private class ColumnHeaderRenderer implements TableCellRenderer {

        ColumnHeaderRenderer(JTable grid) {
            renderer = (DefaultTableCellRenderer) grid.getTableHeader().getDefaultRenderer();
            renderer.setHorizontalAlignment(JLabel.LEFT);
        }

        @Override
        public Component getTableCellRendererComponent(JTable grid, Object value, boolean isSelected, boolean hasFocus, int row, int col) {
            return renderer.getTableCellRendererComponent(grid, value, isSelected, hasFocus, row, col);
        }

        private final DefaultTableCellRenderer renderer;

    }
    
    
    private class RowHeaders extends bka.swing.TableRowHeaders {
        
        @Override
        public String cornerName() {
            return "RPM / Load";
        }
        
        @Override
        public Object rowName(int row) {
            Measurement rowMeasurement = table.getRowMeasurement();
            if (rowMeasurement != null) {
                float stepSize = (rowMeasurement.getMaximum() - rowMeasurement.getMinimum()) / table.getRowCount();
                return Integer.toString((int) (rowMeasurement.getMinimum() + row * stepSize));
            }
            else {
                return Integer.toString(row + 1);
            }
        }
        
    };
    
    private class CellRenderer extends DefaultTableCellRenderer {
        
        CellRenderer() {
            setHorizontalAlignment(DefaultTableCellRenderer.RIGHT);
            activeRenderer.setHorizontalAlignment(DefaultTableCellRenderer.RIGHT);
            activeRenderer.setOpaque(true);
            activeRenderer.setBackground(UIManager.getColor("highlightBackground"));
            activeRenderer.setBorder(activeCellBorder);
        }
        
        @Override
        public Component getTableCellRendererComponent(JTable grid, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
            String valueString = numberFormat.format(value);
            if (column == table.getColumnIndex() && row == table.getRowIndex()) {
                activeColumn = column;
                activeRow = row;
                activeRenderer.setText(valueString);
                return activeRenderer;
            }
            else {
                JLabel renderer = (JLabel) super.getTableCellRendererComponent(grid, valueString, isSelected, hasFocus, row, column);
                return renderer;
            }
        }
        
        private final JLabel activeRenderer = new JLabel();
        
        private final Border activeCellBorder = new LineBorder(UIManager.getColor("Border.highlightColor"), 1) {
            @Override
            public Insets getBorderInsets(Component component) {
                return CellRenderer.this.getInsets();
            }
            @Override
            public Insets getBorderInsets(Component component, Insets insets) {
                return CellRenderer.this.getInsets(insets);
            }
        };
         
    }
    
    
    private class NumberCellEditor extends DefaultCellEditor {
        
        NumberCellEditor() {
            super(new JTextField());
            JTextField textField = getTextField();
            textField.setHorizontalAlignment(JTextField.RIGHT);
            PlainDocument document = (PlainDocument) textField.getDocument();
            filter = new NumberFilter(textField);
            document.setDocumentFilter(filter);
        }
        
        @Override
        public Component getTableCellEditorComponent(JTable grid, Object value, boolean isSelected, int row, int column) {
            value = numberFormat.format(((Float) value).doubleValue());
            return (JTextField) super.getTableCellEditorComponent(grid, value, isSelected, row, column);
        }

        @Override
        public boolean stopCellEditing() {
            if (filter.isValid()) {
                return super.stopCellEditing();
            }
            else {
                return false;
            }
        }

        @Override
        public Object getCellEditorValue() {
            try {
                Object value = super.getCellEditorValue();
                return numberFormat.parse(value.toString()).floatValue(); 
            }
            catch (java.text.ParseException ex) {
                return null;
            }
        }

        private JTextField getTextField() {
            return (JTextField) getComponent();
        }
        
        private final NumberFilter filter;
        
    }
    
    
    private class NumberFilter extends DocumentFilter {
        
        NumberFilter(Component component) {
            this.component = component;
        }
        
        @Override
        public void insertString(FilterBypass bypass, int offset, String text, AttributeSet attributes) throws BadLocationException {
           StringBuilder builder = createBuilder(bypass);
           builder.insert(offset, text);
           if (allowed(builder.toString())) {
              super.insertString(bypass, offset, text, attributes);
           }
        }

        @Override
        public void replace(FilterBypass bypass, int offset, int length, String text, AttributeSet attributes) throws BadLocationException {
           StringBuilder builder = createBuilder(bypass);
           builder.replace(offset, offset + length, text);
           if (allowed(builder.toString())) {
              super.replace(bypass, offset, length, text, attributes);
           }
        }

        @Override
        public void remove(FilterBypass bypass, int offset, int length) throws BadLocationException {
           StringBuilder builder = createBuilder(bypass);
           builder.delete(offset, offset + length);
           if (allowed(builder.toString())) {
              super.remove(bypass, offset, length);
           }
        }
        
        boolean isValid() {
            return valid;
        }
        
        private StringBuilder createBuilder(FilterBypass bypass) throws BadLocationException {
            Document document = bypass.getDocument();
            StringBuilder builder = new StringBuilder();
            builder.append(document.getText(0, document.getLength()));
            return builder;
        }

        private boolean allowed(String text) {
            boolean allowed = true;
            if (text.isEmpty()) {
                valid = false;
            }
            else {
                java.text.ParsePosition position = new java.text.ParsePosition(0);
                Number number = numberFormat.parse(text, position);
                System.out.println(number + "  " + position);
                if (position.getErrorIndex() < 0 && position.getIndex() == text.length() && number != null) {
                    float value = number.floatValue();
                    valid = table.getMinimum() <= value && value <= table.getMaximum();
                }
                else {
                    allowed = false;
                }
            }
            component.setBackground((valid) ? DEFAULT_BACKGROUND : INVALID_BACKGROUND);                
            return allowed;
        }

        private boolean valid = true;
        private final Component component;

    }
    
    
    private class TableListener implements Table.Listener {

        @Override
        public void propertyChanged(Table table, Table.Property property) {
            if (table == TablePanel.this.table) {
                switch (property) {
                    case INDEX:
                        indexChanged();
                        break;
                    case VALUE:
                        valueChanged(grid.getSelectedRow(), grid.getSelectedColumn());
                        break;
                    default:
                        initializationPropertyChanged(property);
                        break;
                }
            }
        }
        
        private void initializationPropertyChanged(Table.Property property) {
            uninitializedProperties.remove(property);
            if (uninitializedProperties.isEmpty()) {
                numberFormat.setMinimumFractionDigits(table.getDecimals());
                numberFormat.setMaximumFractionDigits(table.getDecimals());
                numberFormat.setParseIntegerOnly(table.getDecimals() == 0);
                model.fireTableStructureChanged();
            }
        }
        
        private void indexChanged() {
            int rowIndex = table.getRowIndex();
            int columnIndex = table.getColumnIndex();
            if (rowIndex != activeRow || columnIndex != activeColumn) {
                valueChanged(activeRow, activeColumn);
                valueChanged(rowIndex, columnIndex);
            }
            if (followActiveCell) {
                Rectangle rectangle = grid.getCellRect(table.getRowIndex(), table.getColumnIndex(), true);
                grid.scrollRectToVisible(rectangle);
            }
        }
        
        private void valueChanged(int row, int column) {
            if (0 <= row && row < model.getRowCount() && 0 <= column && column < model.getColumnCount()) {
                model.fireTableCellUpdated(row, column);
            }
        }
        
        /** 
         * Set of properties that must be initalized before this TablePanel can
         * work properly. Initialized properties need to be removed, so this
         * TablePanel is ready for use as soon as the set is empty.
         */
        private final Set<Table.Property> uninitializedProperties = EnumSet.of(
            Table.Property.FIELDS,
            Table.Property.MINIMUM,
            Table.Property.MAXIMUM,
            Table.Property.DECIMALS,
            Table.Property.COLUMN_MEASUREMENT,
            Table.Property.ROW_MEASUREMENT);
        
    }

    
    private Table table;   
    private final java.text.NumberFormat numberFormat = java.text.NumberFormat.getNumberInstance();
    
    private int activeColumn = -1;
    private int activeRow = -1;
    private boolean followActiveCell = true;

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTable grid;
    private javax.swing.JScrollPane scrollPane;
    // End of variables declaration//GEN-END:variables

    private final Listener tablePanelListener;
    private final GridModel model = new GridModel();
    private final TableListener tableListener = new TableListener();
    
    private static final Color DEFAULT_BACKGROUND = UIManager.getColor("Textfield.Background");
    private static final Color INVALID_BACKGROUND = UIManager.getColor("errorBackground");
    
}
