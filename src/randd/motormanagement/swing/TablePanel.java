/*
** Copyright © Bart Kampers
*/

package randd.motormanagement.swing;

import java.awt.*;
import java.awt.event.KeyEvent;
import java.text.*;
import java.util.*;
import java.util.function.*;
import java.util.logging.*;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.table.*;
import javax.swing.text.*;

import randd.motormanagement.system.*;


public class TablePanel extends JPanel {

    
    public interface Listener {
        void startIndexPoll(Table table);
        void setValue(Table table, int column, int row, float value);
        void setProgrammerActivated(Table table, boolean activated);
        void applyProgrammerValue(Table table);
    }
    
    
    public TablePanel(Listener listener, Table table) {
        this.tablePanelListener = Objects.requireNonNull(listener);
        this.table = Objects.requireNonNull(table);
        model = new GridModel();
        tableListener = new TableListener(initalizationProperties(table));
        table.addListener(tableListener);
        initComponents();
        grid.setDefaultRenderer(Object.class, new CellRenderer());
        grid.setDefaultEditor(Object.class, new NumberCellEditor());
        grid.getSelectionModel().addListSelectionListener(evt -> followActiveCell = false);
        JTableHeader columnHeader = grid.getTableHeader();
        columnHeader.setDefaultRenderer(new ColumnHeaderRenderer(grid));
        columnHeader.setResizingAllowed(false);
        columnHeader.setEnabled(false);
        rowHeaders.initialize(model, scrollPane, grid.getRowHeight());
        rowHeaders.setAlignment(JLabel.RIGHT, JLabel.TOP);
        numberFormat.setGroupingUsed(false);
        horizontalInterpolationButton.setVisible(false);
        verticalInterpolationButton.setVisible(false);
        programmerToggleButton.setVisible(false);
        programmerApplyButton.setVisible(false);
    }
    
    private static Set<Table.Property> initalizationProperties(Table table) {
        if ("RpmIndication".equals(table.getName())) {
            return EnumSet.of(Table.Property.FIELDS);
        }
        return EnumSet.of(
            Table.Property.FIELDS,
            Table.Property.MINIMUM,
            Table.Property.MAXIMUM,
            Table.Property.DECIMALS,
            Table.Property.COLUMN_MEASUREMENT,
            Table.Property.ROW_MEASUREMENT);
    } 
    
    Table getTable() {
        return table;
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        scrollPane = new javax.swing.JScrollPane();
        grid = new javax.swing.JTable();
        toolPanel = new javax.swing.JPanel();
        horizontalInterpolationButton = new javax.swing.JButton();
        verticalInterpolationButton = new javax.swing.JButton();
        programmerToggleButton = new javax.swing.JToggleButton();
        programmerApplyButton = new javax.swing.JButton();

        setLayout(new java.awt.BorderLayout());

        grid.setModel(model);
        grid.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_OFF);
        grid.setCellSelectionEnabled(true);
        grid.setRowHeight(30);
        grid.getTableHeader().setReorderingAllowed(false);
        grid.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                grid_mouseClicked(evt);
            }
        });
        grid.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                grid_keyReleased(evt);
            }
        });
        scrollPane.setViewportView(grid);

        add(scrollPane, java.awt.BorderLayout.CENTER);

        horizontalInterpolationButton.setText(Bundle.getInstance().get("HorizontalInterpolation")
        );
        horizontalInterpolationButton.setEnabled(false);
        horizontalInterpolationButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                horizontalInterpolationButton_actionPerformed(evt);
            }
        });
        toolPanel.add(horizontalInterpolationButton);

        verticalInterpolationButton.setText(Bundle.getInstance().get("VerticalInterpolation"));
        verticalInterpolationButton.setEnabled(false);
        verticalInterpolationButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                verticalInterpolationButton_actionPerformed(evt);
            }
        });
        toolPanel.add(verticalInterpolationButton);

        programmerToggleButton.setText(Bundle.getInstance().get("Program"));
        programmerToggleButton.setActionCommand(Bundle.getInstance().get("program"));
        programmerToggleButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                programmerToggleButton_actionPerformed(evt);
            }
        });
        toolPanel.add(programmerToggleButton);

        programmerApplyButton.setText(Bundle.getInstance().get("ProgrammerApply"));
        programmerApplyButton.setEnabled(false);
        programmerApplyButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                programmerApplyButton_actionPerformed(evt);
            }
        });
        toolPanel.add(programmerApplyButton);

        add(toolPanel, java.awt.BorderLayout.SOUTH);
    }// </editor-fold>//GEN-END:initComponents

    private void horizontalInterpolationButton_actionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_horizontalInterpolationButton_actionPerformed
        int[] rows = grid.getSelectedRows();
        int[] columns = grid.getSelectedColumns();
        for (int row : rows) {
            interpolate(
                (index) -> (Float) grid.getValueAt(row, columns[index]),  
                (index, value) -> grid.setValueAt(value, row, columns[index]),
                columns.length - 1);
        }
    }//GEN-LAST:event_horizontalInterpolationButton_actionPerformed

    private void verticalInterpolationButton_actionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_verticalInterpolationButton_actionPerformed
        int[] rows = grid.getSelectedRows();
        int[] columns = grid.getSelectedColumns();
        for (int column : columns) {
            interpolate(
                (index) -> (Float) grid.getValueAt(rows[index], column),  
                (index, value) -> grid.setValueAt(value, rows[index], column),
                rows.length - 1);
        }
    }//GEN-LAST:event_verticalInterpolationButton_actionPerformed

    private static void interpolate(Function<Integer, Float> valueAt, BiConsumer<Integer, Float> setter, int range) {
        float value = valueAt.apply(0);
        float step = (valueAt.apply(range) - value) / range;
        for (int i = 1; i < range; ++i) {
            value += step;
            setter.accept(i, value);
        }
    }    
    
    private void grid_keyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_grid_keyReleased
        switch (evt.getKeyCode()) {
            case KeyEvent.VK_DOWN:
            case KeyEvent.VK_LEFT:
            case KeyEvent.VK_RIGHT:
            case KeyEvent.VK_UP:
                setInterpolationEnabled();
                break;
            default:
                break;
        }
    }//GEN-LAST:event_grid_keyReleased

    private void grid_mouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_grid_mouseClicked
        setInterpolationEnabled();
    }//GEN-LAST:event_grid_mouseClicked

    private void programmerToggleButton_actionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_programmerToggleButton_actionPerformed
        tablePanelListener.setProgrammerActivated(table, programmerToggleButton.isSelected());
        setProgrammingButtonsActivated(programmerToggleButton.isSelected());
    }//GEN-LAST:event_programmerToggleButton_actionPerformed

    private void programmerApplyButton_actionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_programmerApplyButton_actionPerformed
        tablePanelListener.applyProgrammerValue(table);
    }//GEN-LAST:event_programmerApplyButton_actionPerformed

    private void setInterpolationEnabled() {
        horizontalInterpolationButton.setEnabled(grid.getSelectedColumnCount() > 2 && grid.getSelectedRowCount() >= 1);
        verticalInterpolationButton.setEnabled(grid.getSelectedRowCount() > 2 && grid.getSelectedColumnCount() >= 1);
    }
    
    private void setProgrammingButtonsActivated(boolean activated) {
        programmerApplyButton.setEnabled(activated);
        programmerToggleButton.setBackground(UIManager.getColor((activated) ? "selectedBackground" : "Button.background"));
    }
    
    private boolean isMeasurementTable() {
        return table.getColumnMeasurement() != null || table.getRowMeasurement() != null;
    }
        

    private class GridModel extends DefaultTableModel {
        
        @Override
        public int getColumnCount() {
            return table.getColumnCount();
        }

        @Override
        public int getRowCount() {
            return table.getRowCount();
        }
        
        @Override
        public String getColumnName(int column) {
            Measurement columnMeasurement = table.getColumnMeasurement();
            if (columnMeasurement != null) {
                float stepSize = (columnMeasurement.getMaximum() - columnMeasurement.getMinimum()) / table.getColumnCount();
                return Integer.toString((int) (columnMeasurement.getMinimum() + column * stepSize));
            }
            else {
                return null;
            }
        }
        
        @Override
        public Object getValueAt(int row, int column) {
            return table.getField(column, row);
        }
        
        @Override
        public void setValueAt(Object value, int row, int column) {
            try {
                tablePanelListener.setValue(table, column, row, ((Number) value).floatValue());
                modifyingRow = row;
                modifyingColumn = column;
            }
            catch (ClassCastException ex) {
                Logger.getLogger(TablePanel.class.getName()).log(Level.WARNING, "GridModel", ex);
                JOptionPane.showMessageDialog(
                    TablePanel.this, 
                    value.toString(), 
                    "Invalid input",
                    JOptionPane.ERROR_MESSAGE);
            }
            catch (NullPointerException ex) {
                Logger.getLogger(TablePanel.class.getName()).log(Level.WARNING, "GridModel", ex);
            }
        }
        
        @Override
        public boolean isCellEditable(int row, int column) {
            return row != modifyingRow || column != modifyingColumn;
        }
        
        int modifyingColumn = NONE;
        int modifyingRow = NONE;

    }
    
    
    private class ColumnHeaderRenderer implements TableCellRenderer {

        ColumnHeaderRenderer(JTable grid) {
            renderer = (DefaultTableCellRenderer) grid.getTableHeader().getDefaultRenderer();
            renderer.setHorizontalAlignment(JLabel.LEFT);
            renderer.setPreferredSize(new Dimension(0, PREFERRED_HEADER_HEIGHT));
        }

        @Override
        public Component getTableCellRendererComponent(JTable grid, Object value, boolean isSelected, boolean hasFocus, int row, int col) {
            return renderer.getTableCellRendererComponent(grid, value, isSelected, hasFocus, row, col);
        }

        private final DefaultTableCellRenderer renderer;
        private static final int PREFERRED_HEADER_HEIGHT = 35;

    }
    
    
    private class RowHeaders extends bka.swing.TableRowHeaders {
        
        @Override
        public String cornerName() {
            StringBuilder name = new StringBuilder("<html>");
            String columnName = measurementName(table.getColumnMeasurement());
            String rowName = measurementName(table.getRowMeasurement());
            if (columnName != null) {
                name.append(columnName);
                name.append(RIGHT_POINTER);
            }
            name.append("<br/>");
            if (rowName != null) {
                name.append (rowName);
                name.append(DOWN_POINTER);
            }
            return name.append("</html>").toString();
        }

        private String measurementName(Measurement measurement) {
            String name = (measurement != null) ? measurement.getName() : null;
            if (name != null) {
                name = Bundle.getInstance().get(name);
            }
            return name;
        }
        
        @Override
        public Object rowName(int row) {
            Measurement rowMeasurement = table.getRowMeasurement();
            if (rowMeasurement != null) {
                float stepSize = (rowMeasurement.getMaximum() - rowMeasurement.getMinimum()) / table.getRowCount();
                return Integer.toString((int) (rowMeasurement.getMinimum() + row * stepSize));
            }
            if (!isMeasurementTable()) {
                return Integer.toString(row + 1);
            }
            return null;
        }
        
        private static final char DOWN_POINTER = '↓';
        private static final char RIGHT_POINTER = '→';

    };
    
    private class CellRenderer extends DefaultTableCellRenderer {
        
        CellRenderer() {
            setHorizontalAlignment(DefaultTableCellRenderer.RIGHT);
            activeRenderer.setHorizontalAlignment(DefaultTableCellRenderer.RIGHT);
            activeRenderer.setOpaque(true);
            activeRenderer.setBackground(UIManager.getColor("highlightBackground"));
            activeRenderer.setBorder(activeCellBorder);
        }
        
        @Override
        public Component getTableCellRendererComponent(JTable grid, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
            String valueString = numberFormat.format(value);
            if (equals(true, table.isEnabled()) && equals(column, table.getColumnIndex()) && equals(row, table.getRowIndex())) {
                activeColumn = column;
                activeRow = row;
                activeRenderer.setText(valueString);
                return activeRenderer;
            }
            else if (!model.isCellEditable(row, column)) {
                JLabel renderer = new JLabel();
                renderer.setOpaque(true);
                renderer.setBackground(Color.GRAY);
                renderer.setForeground(Color.LIGHT_GRAY);
                renderer.setHorizontalAlignment(DefaultTableCellRenderer.RIGHT);
                renderer.setText(valueString);
                return renderer;
            }
            else {
                return super.getTableCellRendererComponent(grid, valueString, isSelected, hasFocus, row, column);
            }
        }
        
        private <T> boolean equals(T value, Optional<T> optional) {
            return optional.isPresent() && value.equals(optional.get());
        }
        
        private final JLabel activeRenderer = new JLabel();
        
        private final Border activeCellBorder = new LineBorder(UIManager.getColor("Border.highlightColor"), 1) {
            @Override
            public Insets getBorderInsets(Component component) {
                return CellRenderer.this.getInsets();
            }
            @Override
            public Insets getBorderInsets(Component component, Insets insets) {
                return CellRenderer.this.getInsets(insets);
            }
        };
         
    }
    
    
    private class NumberCellEditor extends DefaultCellEditor {
        
        NumberCellEditor() {
            super(new JTextField());
            JTextField textField = getTextField();
            textField.setHorizontalAlignment(JTextField.RIGHT);
            PlainDocument document = (PlainDocument) textField.getDocument();
            filter = new NumberFilter(textField);
            document.setDocumentFilter(filter);
        }
        
        @Override
        public Component getTableCellEditorComponent(JTable grid, Object value, boolean isSelected, int row, int column) {
            return super.getTableCellEditorComponent(grid, "", isSelected, row, column);
        }

        @Override
        public boolean stopCellEditing() {
            if (!filter.isValid()) {
                return false;
            }
            return super.stopCellEditing();
        }

        @Override
        public Object getCellEditorValue() {
            try {
                Object value = super.getCellEditorValue();
                return numberFormat.parse(value.toString()).floatValue(); 
            }
            catch (ParseException ex) {
                return null;
            }
        }

        private JTextField getTextField() {
            return (JTextField) getComponent();
        }
        
        private final NumberFilter filter;
        
    }
    
    
    private class NumberFilter extends DocumentFilter {
        
        NumberFilter(Component component) {
            this.component = component;
        }
        
        @Override
        public void insertString(FilterBypass bypass, int offset, String text, AttributeSet attributes) throws BadLocationException {
           StringBuilder builder = createBuilder(bypass);
           builder.insert(offset, text);
           if (allowed(builder.toString())) {
              super.insertString(bypass, offset, text, attributes);
           }
        }

        @Override
        public void replace(FilterBypass bypass, int offset, int length, String text, AttributeSet attributes) throws BadLocationException {
           StringBuilder builder = createBuilder(bypass);
           builder.replace(offset, offset + length, text);
           if (allowed(builder.toString())) {
              super.replace(bypass, offset, length, text, attributes);
           }
        }

        @Override
        public void remove(FilterBypass bypass, int offset, int length) throws BadLocationException {
           StringBuilder builder = createBuilder(bypass);
           builder.delete(offset, offset + length);
           if (allowed(builder.toString())) {
              super.remove(bypass, offset, length);
           }
        }
        
        boolean isValid() {
            return valid;
        }
        
        private StringBuilder createBuilder(FilterBypass bypass) throws BadLocationException {
            Document document = bypass.getDocument();
            return new StringBuilder(document.getText(0, document.getLength()));
        }

        private boolean allowed(String text) {
            boolean allowed = true;
            if (text.isEmpty() || text.equals(numberFormat.getNegativePrefix())) {
                valid = false;
            }
            else {
                ParsePosition position = new ParsePosition(0);
                Number number = numberFormat.parse(text, position);
                if (position.getErrorIndex() < 0 && position.getIndex() == text.length() && number != null) {
                    float value = number.floatValue();
                    valid = table.getMinimum() <= value && value <= table.getMaximum();
                }
                else {
                    allowed = false;
                }
            }
            component.setForeground((valid) ? DEFAULT_FOREGROUND : INVALID_FOREGROUND);                
            return allowed;
        }

        private boolean valid = true;
        private final Component component;

    }
    
    
    private class TableListener implements Table.Listener {

        public TableListener(Set<Table.Property> initalizationProperties) {
            uninitializedProperties = EnumSet.copyOf(initalizationProperties);
        }
        
        @Override
        public void propertyChanged(Table table, Table.Property property, Object... attributes) {
            if (table.equals(TablePanel.this.table)) {
                switch (property) {
                    case COLUMN_INDEX:
                    case ROW_INDEX:
                        indexChanged();
                        break;
                    case ENABLED:
                        if (activeRow != NONE && activeColumn != NONE) {
                            model.fireTableCellUpdated(activeRow, activeColumn);
                        }
                        break;
                    case PROGRAMMABLE:
                        programmerToggleButton.setVisible((boolean) attributes[0]);
                        programmerApplyButton.setVisible((boolean) attributes[0]);
                        break;
                    case PROGRAMMER_ACTIVATED:
                        programmerToggleButton.setSelected(table.isProgrammerActivated());
                        setProgrammingButtonsActivated(table.isProgrammerActivated());
                        break;
                    case VALUE:
                        valueChanged((int) attributes[1], (int) attributes[0]);
                        break;
                    default:
                        initializationPropertyChanged(property);
                        break;
                }
            }
        }

        private void indexChanged() {
            int rowIndex = indexValueOf(table.getRowIndex().get());
            int columnIndex = indexValueOf(table.getColumnIndex().get());
            if (rowIndex != activeRow || columnIndex != activeColumn) {
                valueChanged(activeRow, activeColumn);
                valueChanged(rowIndex, columnIndex);
            }
            if (followActiveCell) {
                Rectangle rectangle = grid.getCellRect(rowIndex, columnIndex, true);
                grid.scrollRectToVisible(rectangle);
            }
        }
        
        private int indexValueOf(Integer index) {
            if (index == null) {
                return NONE;
            }
            return index;
        }

        private void valueChanged(int row, int column) {
            if (0 <= row && row < model.getRowCount() && 0 <= column && column < model.getColumnCount()) {
                model.modifyingRow = NONE;
                model.modifyingColumn = NONE;
                model.fireTableCellUpdated(row, column);
            }
        }
        
        private void initializationPropertyChanged(Table.Property property) {
            if (uninitializedProperties != null) {
                uninitializedProperties.remove(property);
                if (property == Table.Property.FIELDS) {
                    if (table.getColumnCount() <= 1) {
                        uninitializedProperties.remove(Table.Property.COLUMN_MEASUREMENT);
                    }
                    if (table.getRowCount() <= 1) {
                        uninitializedProperties.remove(Table.Property.ROW_MEASUREMENT);
                    }
                }
                if (uninitializedProperties.isEmpty()) {
                    numberFormat.setMinimumFractionDigits(table.getDecimals());
                    numberFormat.setMaximumFractionDigits(table.getDecimals());
                    numberFormat.setParseIntegerOnly(table.getDecimals() == 0);
                    model.fireTableStructureChanged();
                    rowHeaders.repaintCorner();
                    horizontalInterpolationButton.setVisible(isMeasurementTable() && grid.getColumnCount() > 2);
                    verticalInterpolationButton.setVisible(isMeasurementTable() && grid.getRowCount() > 2);
                    uninitializedProperties = null;
                }
            }
            else {
                Logger.getLogger(TablePanel.class.getName()).log(Level.WARNING, "Unexpected initialization property {0}", property);
            }
        }
        
        /** 
         * Set of properties that must be initialized before this TablePanel can
         * work properly. Initialized properties need to be removed from this set.
         * This TablePanel is ready for use as soon as the set is empty.
         */
        private Set<Table.Property> uninitializedProperties;
        
    }

    
    private final Table table;   
    private final DecimalFormat numberFormat = new DecimalFormat();
    
    private int activeColumn = NONE;
    private int activeRow = NONE;
    private boolean followActiveCell = true;

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTable grid;
    private javax.swing.JButton horizontalInterpolationButton;
    private javax.swing.JButton programmerApplyButton;
    private javax.swing.JToggleButton programmerToggleButton;
    private javax.swing.JScrollPane scrollPane;
    private javax.swing.JPanel toolPanel;
    private javax.swing.JButton verticalInterpolationButton;
    // End of variables declaration//GEN-END:variables

    private final RowHeaders rowHeaders = new RowHeaders();


    private final Listener tablePanelListener;
    private final GridModel model;
    private final TableListener tableListener;
    
    private static final Color DEFAULT_FOREGROUND = UIManager.getColor("TextField.textForeground");
    private static final Color INVALID_FOREGROUND = UIManager.getColor("TextField[Disabled].textForeground");
    
    private static final int NONE = -1;

}
